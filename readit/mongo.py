from __future__ import with_statement

import bson.errors
import functools
import pymongo
import threading
import uuid

from pymongo.objectid import ObjectId

import readit


class Storage(object):
    """I store object states as simple :py:class:`dict` instances.
    
    Instances are stored as dictionaries identified by a unique
    identifier.  The ID is generated by the :py:meth:`save` method
    and assigned to the ``object_id`` attribute of the object.  The
    instances themselves must implement the ``Storable`` protocol
    which is defined as:
    
     - **storable.to_persistence() -> dict**:
     - **Storable.from_persistence(values:dict)**:
     - **storable.object_id**: this is a read/write property that is used as
       the unique object ID in the persistence layer.  It will be assigned
       when the object is stored if it is not already set.
    """

    _CONN = None
    _CONN_LOCK = threading.Lock()

    def __init__(self, storage_url=None, id_extractor=None):
        self.storage_url = storage_url
        self.id_extractor = id_extractor

    def save(self, storage_bin, storable):
        persist = storable.to_persistence()
        if storable.object_id is not None:
            persist['_id'] = ObjectId(storable.object_id)
        conn = self.get_mongo_connection()
        conn[storage_bin].insert(persist)
        if storable.object_id is None:
            storable.object_id = str(persist['_id'])

    def retrieve_one(self, storage_bin, **arguments):
        result = self.retrieve(storage_bin, **arguments)
        if len(result) > 1:
            raise readit.MoreThanOneResultError()
        if len(result) == 0:
            return None
        return result[0]

    def retrieve(self, storage_bin, storage_id=None, clazz=None, **constraint):
        conn = self.get_mongo_connection()
        if storage_id is not None:
            constraint['_id'] = ObjectId(storage_id)
        values = conn[storage_bin].find(**constraint)
        if values and clazz:
            def manufacture_object(data):
                object_id = data.pop('_id')
                instance = clazz.from_persistence(data)
                instance.object_id = str(object_id)
                return instance
            values = (manufacture_object(data) for data in values)
        return list(values)

    def remove(self, storage_bin, storage_id, **constraint):
        constraint['_id'] = ObjectId(storage_id)
        conn = self.get_mongo_connection()
        collection = conn[storage_bin]
        collection.remove(constraint)

    def get_mongo_connection(self):
        if Storage._CONN is None:
            with Storage._CONN_LOCK:
                if Storage._CONN is None:
                    Storage._CONN = pymongo.Connection(host=self.storage_url)
        return Storage._CONN.readit

